<?php

namespace App\Services\Orders;

use App\Models\Order;
use App\Models\Payment;
use App\Enums\OrderStatus;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;
use YooKassa\Client;
use Exception;

class YookassaPaymentService
{
    protected Client $client;
    protected TransitionService $transitionService;

    public function __construct(TransitionService $transitionService)
    {
        $this->transitionService = $transitionService;
        
        // Проверяем наличие обязательных настроек
        $shopId = config('services.yookassa.shop_id');
        $secretKey = config('services.yookassa.secret_key');
        
        if (empty($shopId) || empty($secretKey)) {
            throw new Exception(
                'ЮКасса не настроена. Проверьте переменные YOOKASSA_SHOP_ID и YOOKASSA_SECRET_KEY в .env файле. ' .
                'Подробные инструкции см. в файле YOOKASSA_SETUP.md'
            );
        }
        
        // Создаем клиент в новом формате
        $this->client = new \YooKassa\Client();
        $this->client->setAuth($shopId, $secretKey);
    }

    /**
     * Создать платеж в ЮКасса
     *
     * @param Order $order
     * @param array $paymentOptions
     * @return array
     * @throws Exception
     */
    public function createPayment(Order $order, array $paymentOptions = []): array
    {
        try {
            $paymentData = array(
                'amount' => array(
                    'value' => $order->amount,
                    'currency' => 'RUB'
                ),
                'confirmation' => array(
                    'type' => 'redirect',
                    'return_url' => route('payment.complete', $order->id)
                ),
                'capture' => true,
                'description' => $this->getPaymentDescription($order),
                'metadata' => array(
                    'order_id' => $order->id,
                    'user_id' => $order->user_id,
                    'document_id' => $order->document_id,
                )
            );

            // Если есть данные клиента и email не автогенерированный
            if ($order->user && $order->user->email && !$order->user->hasAutoGeneratedEmail()) {
                $paymentData['metadata']['user_email'] = $order->user->email;
                
                // Добавляем чек для отправки на email
                $paymentData['receipt'] = array(
                    'customer' => array(
                        'email' => $order->user->email,
                    ),
                    'items' => array(
                        array(
                            'description' => $this->getPaymentDescription($order),
                            'quantity' => 1.000,
                            'amount' => array(
                                'value' => $order->amount,
                                'currency' => 'RUB'
                            ),
                            'vat_code' => 1, // НДС 20%
                            'payment_mode' => 'full_payment',
                            'payment_subject' => 'service', // Услуга
                        )
                    )
                );
            }

            // Создаем идемпотентный ключ
            $idempotenceKey = uniqid('', true);
            
            // Создаем платеж
            $response = $this->client->createPayment($paymentData, $idempotenceKey);

            Log::info('ЮКасса платеж создан', [
                'order_id' => $order->id,
                'payment_id' => $response->getId(),
                'status' => $response->getStatus(),
                'amount' => $response->getAmount()->getValue(),
                'has_receipt' => isset($paymentData['receipt']),
                'idempotence_key' => $idempotenceKey
            ]);

            // Сохраняем информацию о платеже в базе
            $payment = $this->savePaymentToDatabase($order, $response);

            return [
                'success' => true,
                'payment_id' => $response->getId(),
                'confirmation_url' => $response->getConfirmation()->getConfirmationUrl(),
                'status' => $response->getStatus(),
                'payment' => $payment
            ];

        } catch (Exception $e) {
            Log::error('Ошибка создания платежа ЮКасса', [
                'order_id' => $order->id,
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString()
            ]);

            throw new Exception('Ошибка при создании платежа: ' . $e->getMessage());
        }
    }

    /**
     * Получить описание платежа
     *
     * @param Order $order
     * @return string
     */
    private function getPaymentDescription(Order $order): string
    {
        return "Доступ к онлайн-сервису генерации текстов";
    }

    /**
     * Обработать webhook уведомление от ЮКасса
     *
     * @param array $requestBody
     * @return bool
     * @throws Exception
     */
    public function handleWebhook(array $requestBody): bool
    {
        try {
            Log::info('Получен webhook от ЮКасса', [
                'event' => $requestBody['event'] ?? 'unknown',
                'object_id' => $requestBody['object']['id'] ?? 'unknown',
                'full_request' => $requestBody
            ]);

            // Проверяем структуру webhook
            if (!isset($requestBody['event']) || !isset($requestBody['object'])) {
                throw new Exception('Неверная структура webhook уведомления');
            }

            $eventType = $requestBody['event'];
            $paymentObject = $requestBody['object'];

            // Проверяем, что это уведомление о платеже
            if (!isset($paymentObject['id']) || !isset($paymentObject['status'])) {
                throw new Exception('Отсутствуют обязательные поля в объекте платежа');
            }

            Log::info('Обработка webhook события', [
                'event' => $eventType,
                'payment_id' => $paymentObject['id'],
                'status' => $paymentObject['status'],
                'amount' => $paymentObject['amount']['value'] ?? 'unknown'
            ]);

            // Находим заказ по метаданным
            $metadata = $paymentObject['metadata'] ?? [];
            if (!isset($metadata['order_id'])) {
                Log::error('Order ID не найден в метаданных платежа', [
                    'payment_id' => $paymentObject['id'],
                    'metadata' => $metadata
                ]);
                throw new Exception('Order ID не найден в метаданных платежа');
            }

            $order = Order::with('user')->find($metadata['order_id']);
            if (!$order) {
                Log::error('Заказ не найден', [
                    'order_id' => $metadata['order_id'],
                    'payment_id' => $paymentObject['id']
                ]);
                throw new Exception('Заказ не найден: ' . $metadata['order_id']);
            }

            // Обрабатываем различные типы событий
            switch ($eventType) {
                case 'payment.succeeded':
                    Log::info('Обработка успешного платежа через webhook', [
                        'order_id' => $order->id,
                        'payment_id' => $paymentObject['id'],
                        'current_order_status' => $order->status->value
                    ]);
                    return $this->handleSuccessfulPayment($order, $paymentObject);

                case 'payment.waiting_for_capture':
                    Log::info('Платеж ожидает подтверждения', [
                        'order_id' => $order->id,
                        'payment_id' => $paymentObject['id']
                    ]);
                    return $this->handlePaymentWaitingForCapture($order, $paymentObject);

                case 'payment.canceled':
                    Log::info('Платеж отменен', [
                        'order_id' => $order->id,
                        'payment_id' => $paymentObject['id']
                    ]);
                    return $this->handleCanceledPayment($order, $paymentObject);

                default:
                    Log::warning('Неизвестный тип webhook события', [
                        'event' => $eventType,
                        'payment_id' => $paymentObject['id'] ?? 'unknown',
                        'order_id' => $order->id
                    ]);
                    return true; // Возвращаем true для неизвестных событий
            }

        } catch (Exception $e) {
            Log::error('Критическая ошибка в webhook ЮКасса', [
                'error' => $e->getMessage(),
                'request_body' => $requestBody,
                'trace' => $e->getTraceAsString(),
                'file' => $e->getFile(),
                'line' => $e->getLine()
            ]);

            // Не выбрасываем исключение, чтобы ЮКасса не повторяла запрос
            return false;
        }
    }

    /**
     * Получить статус платежа
     *
     * @param string $paymentId
     * @return array
     * @throws Exception
     */
    public function getPaymentInfo(string $paymentId): array
    {
        try {
            $payment = $this->client->getPaymentInfo($paymentId);

            return [
                'id' => $payment->getId(),
                'status' => $payment->getStatus(),
                'amount' => $payment->getAmount()->getValue(),
                'currency' => $payment->getAmount()->getCurrency(),
                'metadata' => $payment->getMetadata(),
                'created_at' => $payment->getCreatedAt()->format('Y-m-d H:i:s'),
            ];

        } catch (Exception $e) {
            Log::error('Ошибка получения информации о платеже', [
                'payment_id' => $paymentId,
                'error' => $e->getMessage()
            ]);

            throw new Exception('Ошибка при получении информации о платеже: ' . $e->getMessage());
        }
    }

    /**
     * Принудительно обработать успешный платеж (публичный метод)
     *
     * @param Order $order
     * @param array $paymentData
     * @return bool
     */
    public function forceHandleSuccessfulPayment(Order $order, array $paymentData): bool
    {
        Log::info('Принудительная обработка платежа', [
            'order_id' => $order->id,
            'payment_id' => $paymentData['id'],
            'current_order_status' => $order->status->value
        ]);

        // Дополнительная проверка перед обработкой
        if ($order->status === OrderStatus::PAID) {
            Log::info('Заказ уже оплачен, пропускаем принудительную обработку', [
                'order_id' => $order->id,
                'payment_id' => $paymentData['id']
            ]);
            return true;
        }

        return $this->handleSuccessfulPayment($order, $paymentData);
    }

    /**
     * Сохранить информацию о платеже в базе данных
     *
     * @param Order $order
     * @param mixed $yookassaPayment
     * @return Payment
     */
    protected function savePaymentToDatabase(Order $order, $yookassaPayment): Payment
    {
        return Payment::create([
            'order_id' => $order->id,
            'user_id' => $order->user_id,
            'amount' => $yookassaPayment->getAmount()->getValue(),
            'status' => 'pending',
            'payment_data' => [
                'yookassa_payment_id' => $yookassaPayment->getId(),
                'yookassa_status' => $yookassaPayment->getStatus(),
                'confirmation_url' => $yookassaPayment->getConfirmation() ? $yookassaPayment->getConfirmation()->getConfirmationUrl() : null,
                'payment_method' => 'yookassa',
                'created_at' => now()->toISOString()
            ]
        ]);
    }

    /**
     * Обработать успешный платеж
     *
     * @param Order $order
     * @param array $paymentData
     * @return bool
     */
    protected function handleSuccessfulPayment(Order $order, array $paymentData): bool
    {
        return DB::transaction(function () use ($order, $paymentData) {
            // Находим локальный платеж
            $localPayment = Payment::where('order_id', $order->id)
                ->whereJsonContains('payment_data->yookassa_payment_id', $paymentData['id'])
                ->first();

            if (!$localPayment) {
                Log::warning('Локальный платеж не найден для успешного платежа ЮКассы', [
                    'order_id' => $order->id,
                    'yookassa_payment_id' => $paymentData['id']
                ]);
                return false;
            }

            // КРИТИЧЕСКАЯ ПРОВЕРКА: Если платеж уже обработан, не обрабатываем повторно
            if ($localPayment->status === 'completed') {
                Log::warning('Попытка повторной обработки уже завершенного платежа', [
                    'order_id' => $order->id,
                    'payment_id' => $paymentData['id'],
                    'local_payment_id' => $localPayment->id,
                    'current_status' => $localPayment->status
                ]);
                return true; // Возвращаем true, так как платеж уже обработан
            }

            // Проверяем, не был ли уже начислен баланс для этого заказа
            if ($order->status === OrderStatus::PAID) {
                Log::warning('Заказ уже оплачен, пропускаем начисление баланса', [
                    'order_id' => $order->id,
                    'payment_id' => $paymentData['id'],
                    'order_status' => $order->status->value
                ]);
                
                // Обновляем только статус платежа, но не начисляем баланс
                $paymentDataLocal = $localPayment->payment_data;
                $paymentDataLocal['yookassa_status'] = $paymentData['status'];
                $paymentDataLocal['paid_at'] = now()->format('Y-m-d H:i:s');

                $localPayment->update([
                    'status' => 'completed',
                    'payment_data' => $paymentDataLocal
                ]);
                
                return true;
            }

            // Обновляем статус платежа в базе
            $paymentDataLocal = $localPayment->payment_data;
            $paymentDataLocal['yookassa_status'] = $paymentData['status'];
            $paymentDataLocal['paid_at'] = now()->format('Y-m-d H:i:s');

            $localPayment->update([
                'status' => 'completed',
                'payment_data' => $paymentDataLocal
            ]);

            // Пополняем баланс пользователя
            $amount = $paymentData['amount']['value'] ?? $order->amount;
            $this->transitionService->creditUser(
                $order->user,
                $amount,
                $order->document ? "Платеж за документ \"{$order->document->title}\"" : "Пополнение баланса"
            );

            // Обновляем статус заказа
            $order->update(['status' => OrderStatus::PAID]);

            Log::info('Платеж успешно обработан', [
                'order_id' => $order->id,
                'payment_id' => $paymentData['id'],
                'amount' => $amount,
                'local_payment_id' => $localPayment->id
            ]);

            return true;
        });
    }

    /**
     * Обработать платеж, ожидающий подтверждения
     *
     * @param Order $order
     * @param array $paymentData
     * @return bool
     */
    protected function handlePaymentWaitingForCapture(Order $order, array $paymentData): bool
    {
        try {
            // Для двухэтапных платежей - автоматически подтверждаем
            $captureData = array(
                'amount' => $paymentData['amount']
            );

            $idempotenceKey = uniqid('capture_', true);
            $response = $this->client->capturePayment($captureData, $paymentData['id'], $idempotenceKey);

            Log::info('Платеж автоматически подтвержден', [
                'order_id' => $order->id,
                'payment_id' => $paymentData['id'],
                'capture_status' => $response->getStatus(),
                'idempotence_key' => $idempotenceKey
            ]);

            return true;

        } catch (Exception $e) {
            Log::error('Ошибка при подтверждении платежа', [
                'order_id' => $order->id,
                'payment_id' => $paymentData['id'],
                'error' => $e->getMessage()
            ]);

            return false;
        }
    }

    /**
     * Обработать отмененный платеж
     *
     * @param Order $order
     * @param array $paymentData
     * @return bool
     */
    protected function handleCanceledPayment(Order $order, array $paymentData): bool
    {
        try {
            // Если платеж отменен, обновляем статус заказа
            $order->update(['status' => OrderStatus::CANCELED]);
            Log::info('Платеж отменен, статус заказа обновлен', [
                'order_id' => $order->id,
                'payment_id' => $paymentData['id']
            ]);
            return true;
        } catch (Exception $e) {
            Log::error('Ошибка при обработке отмененного платежа', [
                'order_id' => $order->id,
                'payment_id' => $paymentData['id'],
                'error' => $e->getMessage()
            ]);
            return false;
        }
    }

    /**
     * Проверить подпись webhook согласно документации ЮКассы
     *
     * @param string $httpBody
     * @param string $signature
     * @return bool
     */
    public function verifyWebhookSignature(string $httpBody, string $signature): bool
    {
        // Если webhook secret не настроен, разрешаем обработку
        // так как используются официальные классы уведомлений для валидации
        $webhookSecret = config('services.yookassa.webhook_secret');
        if (!$webhookSecret) {
            Log::info('Webhook secret не настроен, используем валидацию через официальные классы уведомлений');
            return true;
        }

        // Убираем "Basic " из начала заголовка Authorization если есть
        $cleanSignature = str_replace('Basic ', '', $signature);
        
        // Декодируем base64
        $decodedCredentials = base64_decode($cleanSignature);
        if ($decodedCredentials === false) {
            Log::warning('Не удалось декодировать подпись webhook', [
                'signature' => $signature
            ]);
            return false;
        }
        
        // Проверяем формат shopId:secretKey
        $credentials = explode(':', $decodedCredentials, 2);
        if (count($credentials) !== 2) {
            Log::warning('Неверный формат подписи webhook', [
                'credentials_count' => count($credentials)
            ]);
            return false;
        }
        
        $shopId = config('services.yookassa.shop_id');
        $secretKey = config('services.yookassa.secret_key');
        
        // Проверяем соответствие shop_id и secret_key
        $isValid = hash_equals($credentials[0], $shopId) && hash_equals($credentials[1], $secretKey);
        
        if (!$isValid) {
            Log::warning('Неверные данные авторизации в webhook', [
                'expected_shop_id' => $shopId,
                'received_shop_id' => $credentials[0],
                'secret_key_match' => hash_equals($credentials[1], $secretKey)
            ]);
        }
        
        return $isValid;
    }
} 